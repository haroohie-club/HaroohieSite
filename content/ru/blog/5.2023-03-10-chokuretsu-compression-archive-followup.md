---
title: &title 'ROM хакинг Последовательностей Челлендж часть 3 – Сжатие и архивирование последующих действий'
description: &desc 'Jonko отвечает на отзывы и предоставляет более подробную информацию о сжатии и архивировании статей.'
navigation:
  description: *desc
  author: 'Jonko'
  year: 2023
  month: 03
  day: 10
  tags: ['chokuretsu', 'romhacking']
  image: '0005/00_thumbnail.png'
head:
  meta:
  - property: 'og:title'
    content: *title
  - property: 'og:description'
    content: *desc
  - property: 'og:image'
    content: &img https://haroohie.club/images/blog/0005/00_thumbnail.png
  - property: 'og:image:alt'
    content: 'A Nintendo DS featuring Haruhi Suzumiya saying edited text.'
  - property: 'og:url'
    content: 'https://haroohie.club/blog/2023-03-10-chokuretsu-compression-archive-followup'
  - property: 'og:type'
    content: 'article'
  - name: 'twitter:title'
    value: *title
  - name: 'twitter:description'
    value: *desc
  - name: 'twitter:image'
    value: *img
  - name: 'twitter:site'
    value: '@haroohie'
  - name: 'twitter:card'
    value: 'summary_large_image'
---

Мой первоначальный черновик поста в блоге, посвященного архивным файлам Shade bin в Последовательностях, был длинным. Прям очень длинным. Было много вещей, которые мне пришлось вырезать в финальной версии, чтобы передать, как я реверсировал структуру архива и заставил работать повторную вставку файлов. Более того, в ответ на первые два поста возникло несколько распространенных вопросов, и я надеюсь использовать этот пост для каталогизации своих ответов на некоторые из них.

## Никто не знает, что они делают
Когда я начал писать код архива, я просто хотел извлечь файлы и вообще не понимал фактическую структуру архивов bin. Таким образом, я написал код, который просто искал интервал между файлами, чтобы определить их смещения. Даже когда я узнал больше о структуре архива, провел обратную разработку магических целых чисел и работал над заменой файлов и, в конечном итоге, над вставкой файлов, я сохранил эту очень несовершенную архитектуру. Впечатляет, что этот код фактически оставался там _до тех пор, пока я не написал предыдущую запись в блоге_ (lol). Он вызвал ряд ошибок — в частности, мне удалось повредить файл в графическом архиве, потому что между ним и предыдущим файлом не было интервала (т. е. предыдущий файл заканчивался примерно на 0x7F8, а начинался на 0x800).

Мне кажется, что предыдущая запись в блоге могла создать впечатление, что все прошло идеально с самого начала, и я хочу подчеркнуть, что это не так. Для меня это процесс проб и ошибок и постоянного обучения — я даже не понял, что это архивы, пока занимался их реверс-инжинирингом, и вместо этого называл их «пользовательскими файловыми системами»

![A Discord message reading Custom Filesystem](/images/blog/0005/01_custom_filesystem_blunder.png)

Только когда [Ermii](https://www.ermiisoft.net/) вежливо спросил, являются ли они архивами, я понял, что... да, именно ими они и являются.

## Длина файла
Что я упустил из архивного поста, так это то, что я не делал обратную разработку всего архива сразу. Код был написан ad-hoc, поскольку я выяснял конкретные вещи здесь и там. Я вычислил смещения еще до того, как понял, что остальные магические целые числа закодированы для длины, поэтому я заменял файлы в архивах, не меняя их длину соответствующим образом. Это привело к таким прекрасным вещам:

![Главный экран Последовательностей со значительными повреждениями в нескольких элементах пользовательского интерфейса.](/images/blog/0005/02_haruohno.png)

Попытка заменить графические файлы привела к повреждению, поскольку моя процедура сжатия была менее эффективна, чем та, которую использовали разработчики, что означало, что сжатые файлы, которые я повторно вставлял в игру, были длиннее, чем ожидалось. Я потратил много времени, пытаясь выяснить, что происходит, прежде чем я наконец определил [кодировку длины файла](/blog/2022-11-02-chokuretsu-archives#the-unhinged-file-length-routine).

![The Chokuretsu main screen without any corruption and with haruhi cool written over Haruhi's face](/images/blog/0005/03_haruhi_cool.png)

Намного лучше!

## Написание тестов
Так что было много проб и ошибок, что означало, что мне нужно было иметь возможность проверить, что такие вещи, как процедура сжатия или программы повторной вставки архива, работают согласованно. Фантастический способ сделать это — _написание тестов_, и это именно то, что я сделал. Смотрите тест для реализации сжатия, который я написал ниже:

```csharp
[Test]
[TestCase("evt_000", TestVariables.EVT_000_DECOMPRESSED, TestVariables.EVT_000_COMPRESSED)]
[TestCase("evt_66", TestVariables.EVT_66_DECOMPRESSED, TestVariables.EVT_66_COMPRESSED)]
[TestCase("evt_memorycard", TestVariables.EVT_MEMORYCARD_DECOMPRESSED, TestVariables.EVT_MEMORYCARD_COMPRESSED, false)]
[TestCase("grp_c1a", TestVariables.GRP_C1A_DECOMPRESSED, TestVariables.GRP_C1A_COMPRESSED, false)]
[TestCase("evt_test", TestVariables.EVT_TEST_DECOMPRESSED, TestVariables.GRP_TEST_COMPRESSED)]
[TestCase("grp_test", TestVariables.GRP_TEST_DECOMPRESSED, TestVariables.GRP_TEST_COMPRESSED)]
public void CompressionMethodTest(string filePrefix, string decompressedFile, string originalCompressedFile)
{
	byte[] decompressedDataOnDisk = File.ReadAllBytes(decompressedFile);
	byte[] compressedData = Helpers.CompressData(decompressedDataOnDisk);
	File.WriteAllBytes($".\\inputs\\{filePrefix}_prog_comp.bin", compressedData);

	if (!string.IsNullOrEmpty(originalCompressedFile))
	{
    	Console.WriteLine($"Original compression ratio: {(double)File.ReadAllBytes(originalCompressedFile).Length / decompressedDataOnDisk.Length * 100}%");
	}
	Console.WriteLine($"Our compression ratio: {(double)compressedData.Length / decompressedDataOnDisk.Length * 100}%");

	byte[] decompressedDataInMemory = Helpers.DecompressData(compressedData);
	File.WriteAllBytes($".\\inputs\\{filePrefix}_prog_decomp.bin", decompressedDataInMemory);
	Assert.AreEqual(StripZeroes(decompressedDataOnDisk), StripZeroes(decompressedDataInMemory), message: "Failed in implementation.");
}
```

Этот тест сжимает некоторые данные, а затем распаковывает их, чтобы проверить, что распакованный файл идентичен исходному. Это использовалось неоднократно при отладке процедуры сжатия, чтобы убедиться, что она работает, когда я реализовал каждую ее часть. Кстати об этом…

## Процедура сжатия
У меня возникло несколько вопросов о том, как я на самом деле реализовал процедуру сжатия, поэтому я решил немного в этом разобраться.

Я думаю, что основной процесс на самом деле довольно прост для понимания: по сути, мы просто обращаем то, что делает процедура распаковки. Например, при распаковке файла мы можем сначала столкнуться с байтом с очищенным верхним битом и установленным вторым битом (т. е. `0b01xxxxxx`), что согласно [алгоритму, который мы реверсировали](/blog/2022-10-19-chokuretsu-compression) означает, что мы берем нижние 6 бит и добавляем 4, а затем повторяем следующий байт столько же раз (например, если мы встретим `43 05` в сжатом буфере, мы запишем семь байтов `05` в распакованный буфер). Таким образом, при сжатии мы ищем четыре или более повторяющихся байта подряд — если мы сталкиваемся с таким повторением, то мы кодируем управляющий байт, за которым следует повторяющийся байт (например, если мы встречаем `05 05 05 05 05 05 05` в распакованном буфере, мы записываем `43 05` в сжатый буфер).

Вот, в принципе, и весь процесс. Он становится довольно сложным для «скользящего словаря», характерного для [сжатия LZ](https://en.wikipedia.org/wiki/LZ77_and_LZ78) (который я называю `lookback`s в своем коде). Для них я по сути веду работающий словарь каждой четырехбайтовой последовательности в файле и проверяю, есть ли в этом словаре текущая четырехбайтовая последовательность. Если есть, я вставляю управляющий код для последовательности lookback в сжатый буфер.

## Поиск наименований файлов
Я солгал, умолчав о заголовке архива — там есть не только раздел магических целых чисел! Если вы прокрутите вниз за пределы магических целых чисел, то увидите еще один раздел той же длины, что и предыдущий, а затем раздел после него, у которого не было четко определенной длины, но записи которого казались соблазнительно шаблонными. В течение практически всей разработки утилит Последовательностеей, я полностью игнорировал эти два раздела — буквально пропуская их в коде. 

![A hex editor showing a section of a bin archive file with tons of incomprehensible ASCII text in it](/images/blog/0005/04_filenames_section.png)

Когда я писал предыдущий пост, я еще раз взглянул на последний из этих двух разделов, так как он показался мне захватывающим. Очевидно, здесь что-то было — в самом начале я прокомментировал, что это могут быть имена файлов, но, очевидно, они казались бессмыслицей... верно?

Теперь, когда я уже довольно далеко продвинулся в проекте, в моем распоряжении было много знаний. Я вспомнил, что некоторые файлы событий имели заголовки вроде `EV1_000`.

![A hex editor showing a portion of an event file with the text EV1_001](/images/blog/0005/05_filename.png)

Итак, по прихоти, я вынул все «имена файлов» и начал искать/заменять в VS Code по одной букве за раз. Довольно быстро стало ясно, что это на самом деле имена файлов, просто зашифрованные. Я написал быструю процедуру для их расшифровки, и внезапно просмотр файлов стал немного проще!

![An editor with all of the files in dat.bin listed alongside their filenames](/images/blog/0005/06_deciphered_filenames.png)

## Другие случайные вещи

### Раскрыта процедура определения длины файла Unhinged
Еще кое-что интересное: после второго сообщения в блоге человек по имени Ethanol зашел на сервер Haroohie Discord и скинул бомбу, объяснив, что на самом деле делает процедура определения длины файла

![A Discord message from a user named Ethanol; the message contents are reproduced below this image](/images/blog/0005/07_ethanol_division.png)

> Да! Но я заметил кое-что, о чем, я не уверен, уже упоминалось ранее, о «независимой процедуре длины файла»
>
> И я хотел бы это упомянуть
>
> Jonko просто переделал деление в своей реализации \:P
>
> Независимая функция — это просто быстрая функция целочисленного деления, которую сделал компилятор

Все верно, это просто деление. 🙃 Я проверил это с тех пор, и действительно, это то, что нужно. Немного быстрее просто разделить, чем делать мою странную штуку, ха-ха.

![A Google Docs comment from my editor, Gordon Ramsay, reading Would you like to apologize to the devs, who you thought were fucking with you specifically](/images/blog/0005/08_apology.png)

По рекомендации моего редактора я хотел бы воспользоваться этой возможностью, чтобы извиниться перед разработчиками Последовательностей, которые, на самом деле, не шутили конкретно надо мной в этом конкретном случае.

### Хардкорно заданная максимальная длина файла
Одна из проблем, с которой мы столкнулись вскоре после того, как расшифровали архив, заключалась в том, что игра начала вылетать при попытке загрузить один из самых ранних файлов событий. Как мы рассмотрим в последующих постах, файлы событий обязательно становятся длиннее после того, как мы их редактируем. После долгих расследований выяснилось, что мы столкнулись с проблемой, когда в игре была жестко задана максимальная длина файла, которую мы превышали. Это было что-то, что было полностью за пределами архива и закодировано как константа в реальном коде игры. Было четыре места, где это было закодировано, но вот одно:

```arm
RAM:02033F00                 MOV     R0, #0x12000
RAM:02033F04                 BL      sub_202E1C8
```

В следующем посте мы расскажем, как мы делаем взлом ассемблера, но вкратце для исправления этой проблемы потребовался взлом ассемблера, поскольку нам пришлось внести исправления в файл новой длины:

```arm
ahook_02033F00:
    mov r0, #0x16000
    bx lr
```

Все, что это делает, это изменяет максимальную длину с 0x12000 на 0x16000. Легко фиксисться, но тем не менее это раздражающая проблема, с которой приходится сталкиваться!

## Скоро увидимся!
Это более короткий пост, но я хотел убедиться, что я затронул некоторые вещи, которые я оставил несказанными в предыдущих постах. Пожалуйста, с нетерпением ждите следующих постов в серии, которые будут посвящены тому, как я провел обратную разработку определенных файлов игры!
